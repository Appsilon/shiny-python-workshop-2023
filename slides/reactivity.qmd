---
title: "Session 2 slides"
author: "Gordon Shotwell"
format: 
  revealjs:
      incremental: true   
---
```{python}
# | echo: false
import os

os.chdir("..")
from helpers import problem_tabs, include_shiny_folder

```

# Reactivity overview

## How did Shiny do that?

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## How did Shiny do that?

- We told Shiny _what_ to do
- We didn't tell Shiny _when_ to do it

## How do other frameworks work?

- Streamlit: rerender everything everwhere all the time
- Dash/Panel/Gradio: Define callback functions

## Event driven programming

- You have to do it
- Easy to get wrong
- Hard to tell when you've gotten it wrong

## What's a better way?

We can infer the relationship between components, and use those relationships to optimally rerender the app.

## Outputs and recipes

```{.python code-line-numbers="5,12"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Recipes and inputs

```{.python code-line-numbers="4,13"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> R{Recipe}
  R --> Sc((Text))
```

## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> Sc((Text))
```

## Declarative programming

- Tell Shiny what you want to happen
- Trust that the framework will keep everything up-to-date
- You're setting the menu, not doing the cooking

## Event-driven programming
![](images/carmy-yelling.webp)

## Reactive programming
![](images/carmy-whites.png)

## Your turn

Draw the graph of this application

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## Reactive graph

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
    Sl[Slider]  --> Sc 
  Sl --> M((Dist Plot))
```

## Slider changes

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider]:::changed --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider]:::changed --> Sc 
  Sl --> M((Dist Plot)):::changed
  
  classDef changed fill:#f96
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot)):::changed
  
  classDef changed fill:#f96
```

## Update
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Checkbox changes
```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> Sc 
  Sl --> M((Dist Plot))
  
  classDef changed fill:#f96
```

## Reactivity scales

- Every Shiny app uses this pattern
- Works for dynamic UIs
- Shiny is lazy 

## Your turn

TODO: Insert reactivity exercise here

# Reactive calculations

## Handling repetition

- So far we've been working with flat reactive graphs
- Each input is passed to a rendering function which produces an output
- Input -> Recipe -> Output can produce repetitive, inefficient applications
- `@reactive.Calc` lets you define calculations which are consumed by downstream functions
- This adds intermediary nodes to the reactive graph

## Reactive Calc example

```{python}
# | echo: false
# | output: asis

include_shiny_folder("apps/examples/2.0-simple-reactive-calc")
```

## Reactive Calc example
```{.python}
    @output
    @render.table
    def df():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        return df

    @output
    @render.plot
    def hist():
        rand = np.random.rand(input.n_rows(), 1)
        df = pd.DataFrame(rand, columns=["col_1"])
        plot = (
            ggplot(df, aes(x="col_1"))
            + geom_histogram(binwidth=0.1, fill="blue", color="black")
            + labs(x="Random Values", y="Frequency", title="Histogram of Random Data")
        )
        return plot
```