---
title: "Session 2 slides"
author: "Gordon Shotwell"
format: revealjs
---
```{python}
# | echo: false
import os

os.chdir("..")
from helpers import problem_tabs, include_shiny_folder

```

## How did Shiny do that?

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## How did Shiny do that?

- We told Shiny _what_ to do
- We didn't tell Shiny _when_ to do it

## How do other frameworks work?

- Streamlit: rerender everything everwhere all the time
- Dash/Panel/Gradio: Define callback functions

## Event driven programming

- You have to do it
- Easy to get wrong
- Hard to tell when you've gotten it wrong

## What's a better way?

We can infer the relationship between components, and use those relationships to optimally rerender the app.

## Outputs and recipes

```{.python code-line-numbers="5,12"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Recipes and inputs

```{.python code-line-numbers="4,13"}
from shiny import Inputs, Outputs, Session, App, render, ui

app_ui = ui.page_fluid(
    ui.input_slider("n", "N", 0, 100, 20),
    ui.output_text_verbatim("txt"),
)


def server(input: Inputs, output: Outputs, session: Session):
    @output
    @render.text
    def txt():
        return f"n*2 is {input.n() * 2}"


app = App(app_ui, server)
```

## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> R{Recipe}
  R --> Sc((Text))
```

## Reactive graph

```{mermaid}
flowchart TD
  S[Slider] --> Sc((Text))
```

## Declarative programming

- Tell Shiny what you want to happen
- Trust that the framework will keep everything up-to-date

## Your turn

Draw the graph of this application

```{python}
# | echo: false
# | output: asis
include_shiny_folder(
    "apps/problem-sets/1-getting-started/1.10-add-plot",
    file_name="app-solution.py",
    exclusions=["app.py"],
    components="viewer",
    viewer_height=500,
)
```

## Reactive graph

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
```

## Slider changes

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider]:::changed --> T((Table))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot)):::changed
  Sl[Slider]:::changed --> T((Table)):::changed
  
  classDef changed fill:#f96
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot)):::changed
  Sl[Slider] --> T((Table)):::changed
  
  classDef changed fill:#f96
```

## Update
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

## Checkbox changes
```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

## Invalidated

```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

## Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

## Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```