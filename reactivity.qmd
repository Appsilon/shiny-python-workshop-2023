---
title: "Basic Reactivity"
code-annotations: hover
---

# The reactive graph
```{python}
# | echo: false

from helpers import include_shiny_folder, problem_tabs

```

In the last section we built a simple shiny app which allowed the user to filter a dataframe and display two plots.
One thing you might notice about the code which genrated this application is that while we specify _what_ should happen in response to a user's action, we don't actually specify _when_ it should happen. 
We don't have anything like cllback functions which define when a calculation should be run, so how does Shiny know when to run the code to keep everything up to date?

Shiny is different from many other frameworks because it is declarative. 
Instead of specifying when code should run, you specify recipes for creating the output you want to run, and then leave it up to Shiny to figure out when to rerun them. 
This greatly simplifies application develpment because managing interaction is the most difficult part of web development, and for the most part Shiny will do a good job managing interaciton.
Shiny does this by inferring a **reactive computation graph** for your application and reredenering downstream elements only if the upstream elements change.

This pattern leads to two main benefits for Shiny users:

1) The Shiny UI renders extremely efficiently
2) You do not need to explicitly tell Shiny when to rerender things


Let's draw the reactive graph for the application from the previous lesson. 
This app has two inputs, and three outputs, but the checkbox to add a trendline is only used by one of the outputs.

For the purposes of this course we're going to draw this as a top down directed acyclic graph (DAG) and put them to the right fo the app:

:::: {.grid .column-screen-inset}
::: {.g-col-12 .g-col-md-9}
```{python}
#| echo: false
#| output: asis  
 include_shiny_folder(
     "apps/problem-sets/1.5-add-plot", file_name="app-solution.py", exclusions=["app.py"]
 )
```
:::

::: {.g-col-12 .g-col-md-3 #vcenter}
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
```
:::
::::

# Steping through the interaction

It's worth walking through the interaction of this simple app to develop an intuition about how Shiny works. 
When the app is first runs, Shiny identifies all of the dependencies in the app, to keep track of what needs to change when an input changes. 
When an input changes downstream elements are **invalidated** which means that they are flagged for recalculation. 
Shiny then recalculates each element which needs to be recalculated but does not render the elements whih don't depend on that input. 

### User changes the slider

When the user changes an input, this invalidates any dependencies, which tells Shiny that those dependencies need to be recalculated with the new value. 

:::: {.columns}
::: {.column width="45%"}
#### Slider changes
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider]:::changed --> T((Table))
  
  classDef changed fill:#f96
```

#### Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot)):::changed
  Sl[Slider] --> T((Table)):::changed
  
  classDef changed fill:#f96
```
:::

::: {.column width="5%"}
<!-- empty column to create gap -->
:::

::: {.column width="45%"}
#### Invalidated

```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot)):::changed
  Sl[Slider]:::changed --> T((Table)):::changed
  
  classDef changed fill:#f96
```

#### Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```
:::
::::

### User changes the checkbox

When the user changes the checkbox the exact same process repeats itself, however, becasue only one output depends on the checkbox, only one element is recalculated.

:::: {.columns}
::: {.column width="45%"}
#### Slider changes
```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

#### Recalculate
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```
:::

::: {.column width="5%"}
<!-- empty column to create gap -->
:::

::: {.column width="45%"}
#### Invalidated

```{mermaid}
flowchart TD
  C[Checkbox]:::changed --> Sc((Scatter\nPlot)):::changed
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```

#### Updated
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl --> Sc 
  Sl --> M((Dist Plot))
  Sl[Slider] --> T((Table))
  
  classDef changed fill:#f96
```
:::
::::

This simple process of changing inputs, invalidating dependencies, and recaulating values turns out to scale to very complicated applications. 
As a result it's a good idea to think through the computation graph whenever you're looking to understand or refactor a Shiny application.

# Reactive Calculations

The penguins application we've been working with contains a bit of repetition.
Each of the rendering functions contain this code which copies and filters the main dataset:

```
df = penguins.copy()
filtered = df.loc[df["Body Mass (g)"] < input.mass()]
```

A little bit of repeittion like this is not the end of the world, but Shiny rewards fairly strict adherence to the principle that you should not repeat itself. 
The main reason why you be strict about this is that repetitive Shiny code will usually lead to an inefficient final application because a calculation will run more times than it needs to. 
For example in this app each time we change the filter the dataset is being copied and filtered three times when ideally we should only need to copy it once.
As your app grows in complexity, or starts executing more intensive computations this repetition will noticibly slow your app down. 
**Reactive calcuations** allow you to store the result of a calculation and re-use it across other components. 
The reactive calculaton is reactive in that it will be invalidated and rerendered just like any other reactive element while allowing other elements to retrieve the value of that calculation without reexecuting it. 

To create a reactive calculation you need to decorate a function with `@reactive.Calc` and call it as you would an input object. 
In this case we create a function called `filt_df` which contains the filtering logic and call it in the render method with `filt_df()`.
This improves the application both because the filtration logic is kept in one place, and also because it the app UI will not recalculate the value more than necessary. 

```{.python}
  @reactive.Calc
  def filt_df():
      df = penguins.copy()
      filtered = df.loc[df["Body Mass (g)"] < input.mass()]
      return filtered
  
  @output
  @render.plot
  def dist():
      return dist_plot(filt_df())
```

As you can see in the final application, extracting the filtration logic into a reactive hasn't changed the app behaviour, but has added another node in the computation graph.

:::: {.grid .column-screen-inset}
::: {.g-col-12 .g-col-md-9}
```{python}
#| echo: false
#| output: asis  
 include_shiny_folder("apps/examples/2.1-reactive-calc")
```
:::

::: {.g-col-12 .g-col-md-3 #vcenter}
```{mermaid}
flowchart TD
  C[Checkbox] --> Sc((Scatter\nPlot))
  Sl[Slider] --> F[Filtered\nData]
  F --> Sc 
  F --> T((Table))
  F --> M((Dist Plot))

```
:::
::::

